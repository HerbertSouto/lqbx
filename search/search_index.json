{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bem-vindo ao projeto","text":"<p>Este \u00e9 o reposit\u00f3rio de documenta\u00e7\u00e3o para o projeto Python desenvolvido. Aqui voc\u00ea encontrar\u00e1 todas as informa\u00e7\u00f5es necess\u00e1rias para configurar e rodar o projeto.</p>"},{"location":"details/","title":"Consultas SQL","text":""},{"location":"details/#what-are-the-10-most-expensive-products-in-the-company","title":"What are the 10 most expensive products in the company?","text":"<p>para responder essa pergunta utilizei a seguinte query: </p> <pre><code>SELECT \n    PRODUCT_COD,\n    PRODUCT_NAME,\n    PRODUCT_VAL\nFROM \ndata_product\nORDER BY \n    PRODUCT_VAL DESC\nLIMIT 10;\n</code></pre>"},{"location":"details/#resultado-da-consulta","title":"Resultado da consulta","text":""},{"location":"details/#what-sections-do-the-bebidas-and-padaria-departments-have","title":"What sections do the 'BEBIDAS' and 'PADARIA' departments have?","text":"<p>para responder essa pergunta utilizei a seguinte query: </p> <p><pre><code>SELECT \n    DEP_NAME,\n    SECTION_NAME\nFROM \ndata_product dp \nWHERE \n    DEP_NAME IN ('BEBIDAS', 'PADARIA')\nGROUP BY \n    DEP_NAME, SECTION_NAME;\n</code></pre> Ou seja, dentro do departamento de BEBIDAS, temos: <code>bebidas</code>, vinhos, cervejas e refrescos. J\u00e1 em PADARIA,  doces-e-sobremesas, queijos-e-frios, <code>padaria</code> e <code>gestante</code>.</p> <p>OBS: Vale ressaltar as sess\u00f5es em destaque, sess\u00e3o de gestante no departamento padaria, n\u00e3o parece fazer sentido. E a sess\u00e3o com o mesmo nome do departamento, vale entender a regra do neg\u00f3cio.</p>"},{"location":"details/#resultado-da-consulta_1","title":"Resultado da consulta","text":""},{"location":"details/#what-was-the-total-sale-of-products-in-of-each-business-area-in-the-first-quarter-of-2019","title":"What was the total sale of products (in $) of each Business Area in the first quarter of 2019?","text":"<p>Nesta query foi levado em considera\u00e7\u00e3o que para encontrar o valor total de vendas, multiplicamos o valor pela quantidade. Mas se o campo valor, j\u00e1 est\u00e1 refletido isso. A query mudaria apenas o <code>SUM</code> no <code>SELECT</code> para <code>SUM(ps.SALES_VALUE)</code></p> <pre><code>SELECT \n    sc.BUSINESS_NAME,\n    SUM(ps.SALES_QTY * ps.SALES_VALUE) AS TOTAL_SALES\nFROM \n    data_product_sales ps\nJOIN \n    data_store_cad sc ON ps.STORE_CODE = sc.STORE_CODE\nWHERE \n    ps.DATE &gt;= '2019-01-01' AND ps.DATE &lt; '2019-04-01'  \nGROUP BY \n    sc.BUSINESS_NAME\nORDER BY \n    TOTAL_SALES DESC;  \n</code></pre>"},{"location":"details/#resultado-da-consulta_2","title":"Resultado da consulta","text":""},{"location":"details/#arquitetura-do-projeto","title":"Arquitetura do Projeto","text":"<p>O projeto foi organizado em quatro arquivos principais, utilizando conceitos de Programa\u00e7\u00e3o Orientada a Objetos para maior modularidade:</p> <p>Classe <code>Database</code>:    - Respons\u00e1vel por gerenciar a conex\u00e3o com o banco de dados MySQL.    - A fun\u00e7\u00e3o <code>retrieve_data</code> permite que a consulta seja feita de maneira flex\u00edvel, com base em par\u00e2metros fornecidos (ex.: <code>product_code</code>, <code>store_code</code> e intervalo de <code>date</code>).</p> <p>Abstra\u00e7\u00e3o com POO:    - A Programa\u00e7\u00e3o Orientada a Objetos foi utilizada para encapsular a l\u00f3gica da conex\u00e3o e consulta dentro da classe <code>Database</code>. Isso facilita a reutiliza\u00e7\u00e3o e modulariza\u00e7\u00e3o do c\u00f3digo em diferentes partes do projeto.    - A fun\u00e7\u00e3o criada foi testada e implementada no <code>case_1</code>.</p> <ul> <li><code>database.py</code>: Classe respons\u00e1vel pela conex\u00e3o com o banco de dados MySQL e pela execu\u00e7\u00e3o de consultas SQL.</li> </ul> <pre><code>import mysql.connector\nimport pandas as pd\nfrom mysql.connector import Error\n\nclass Database:\n    def __init__(self, host, port, user, password, database):\n        self.host = host\n        self.port = port\n        self.user = user\n        self.password = password\n        self.database = database\n        self.cnx = None\n\n    def connect(self):\n        \"\"\"Estabelece a conex\u00e3o com o banco de dados.\"\"\"\n        try:\n            self.cnx = mysql.connector.connect(\n                host=self.host,\n                port=self.port,\n                user=self.user,\n                password=self.password,\n                database=self.database\n            )\n            print(\"Connection ok.\")\n        except Error as e:\n            print(f\"Error: {e}\")\n\n    def close(self):\n        \"\"\"Fecha a conex\u00e3o com o banco de dados.\"\"\"\n        if self.cnx.is_connected():\n            self.cnx.close()\n            print(\"Connection closed.\")\n\n    def retrieve_data(self, product_code=None, store_code=None, date=None):\n        \"\"\"Recupera dados da tabela data_product_sales com base nos par\u00e2metros fornecidos.\"\"\"\n        try:\n            if self.cnx is None or not self.cnx.is_connected():\n                self.connect()\n\n            query = \"SELECT * FROM data_product_sales WHERE 1=1\"  # Come\u00e7ar a consulta com um true\n            params = []\n\n            if product_code is not None:\n                query += \" AND product_code = %s\"\n                params.append(product_code)\n\n            if store_code is not None:\n                query += \" AND store_code = %s\"\n                params.append(store_code)\n\n            if date is not None and len(date) == 2:\n                query += \" AND date BETWEEN %s AND %s\"\n                params.extend(date)\n\n            # Executa a consulta\n            with self.cnx.cursor() as cur:\n                cur.execute(query, params)\n                results = cur.fetchall()\n\n            # Cria um DataFrame com os resultados\n            df = pd.DataFrame(results, columns=[i[0] for i in cur.description])\n            return df\n\n        except Error as e:\n            print(f\"Error: {e}\")\n            return pd.DataFrame()  # Retorna um DataFrame vazio em caso de erro\n    def execute_query(self, query):\n        \"\"\"Executa uma consulta SQL e retorna um DataFrame.\"\"\"\n        if self.cnx is None or not self.cnx.is_connected():\n            self.connect()\n        try:\n            df = pd.read_sql(query, self.cnx)\n            return df\n        except Error as e:\n            print(f\"Error executing query: {e}\")\n            return pd.DataFrame()  # Retorna um DataFrame vazio em caso de erro\n</code></pre>"},{"location":"details/#case-1-verifica-a-funcao-de-recuperacao-de-dados-da-tabela-data_product_sales","title":"Case 1: Verifica a fun\u00e7\u00e3o de recupera\u00e7\u00e3o de dados da tabela <code>data_product_sales</code>.","text":"<p>Utiliza a classe Database para conex\u00e3o e faz uso da fun\u00e7\u00e3o <code>retrieve_data</code> para realizar consultar com filtros no banco.</p> <pre><code>import os\nfrom dotenv import load_dotenv\nfrom database import Database\n\nload_dotenv()\n\ndef test_retrieve_data():\n    db = Database(\n        host=os.getenv('DB_HOST'),\n        port=int(os.getenv('DB_PORT')),\n        user=os.getenv('DB_USER'),\n        password=os.getenv('DB_PASSWORD'),\n        database=os.getenv('DB_NAME')\n    )\n\n    # Teste\n    my_data = db.retrieve_data(product_code=18, store_code=1, date=['2019-01-01', '2019-01-31'])\n    print(\"Valid parameters\")\n    print(my_data)\n\n    db.close()\n\nif __name__ == \"__main__\":\n    test_retrieve_data()\n</code></pre>"},{"location":"details/#case-2-processamento-de-consultas-e-calculo-do-ticket-medio-tm","title":"Case 2: Processamento de Consultas e C\u00e1lculo do Ticket M\u00e9dio (TM)","text":"<p>Este caso mostra como processar dados de vendas e calcular o Ticket M\u00e9dio (TM) usando a classe <code>Database</code> e o pandas para manipula\u00e7\u00e3o dos dados. O c\u00f3digo foi estruturado da seguinte maneira:</p> <pre><code>import pandas as pd\nfrom database import Database\nimport os\nfrom dotenv import load_dotenv\n\n\nload_dotenv()\n\n\nclass QueryProcessor:\n    def __init__(self, db: Database):\n        self.db = db\n\n    def fetch_stores(self):\n        query = \"\"\"\n        SELECT\n            STORE_CODE,\n            STORE_NAME,\n            BUSINESS_NAME,\n            BUSINESS_CODE\n        FROM data_store_cad\n        \"\"\"\n        return self.db.execute_query(query)\n\n    def fetch_sales(self, start_date, end_date):\n        query = f\"\"\"\n        SELECT\n            STORE_CODE,\n            DATE,\n            SALES_VALUE,\n            SALES_QTY\n        FROM data_store_sales\n        WHERE DATE BETWEEN '{start_date}' AND '{end_date}'\n        \"\"\"\n        return self.db.execute_query(query)\n\n    def process_queries(self, start_date, end_date):\n        stores_df = self.fetch_stores()\n        sales_df = self.fetch_sales(start_date, end_date)\n\n        merged_df = pd.merge(stores_df, sales_df, on='STORE_CODE', how='left')\n\n        average_sales_df = merged_df.groupby(['STORE_NAME', 'BUSINESS_NAME']).agg(\n            Average_Sales_Value=('SALES_VALUE', 'sum'),\n            Total_Sales_Qty=('SALES_QTY', 'sum')\n        ).reset_index()\n\n        # Calcula a m\u00e9dia e arredonda\n        average_sales_df['TM'] = average_sales_df.apply(\n            lambda row: round(row['Average_Sales_Value'] / row['Total_Sales_Qty'], 2) if row['Total_Sales_Qty'] &gt; 0 else 0, \n            axis=1\n        )\n\n        # Renomeia as colunas conforme o necess\u00e1rio\n        average_sales_df = average_sales_df[['STORE_NAME', 'BUSINESS_NAME', 'TM']]\n        average_sales_df.columns = ['Loja', 'Categoria', 'TM']\n\n        return average_sales_df\n\nif __name__ == \"__main__\":\n    # Crie uma inst\u00e2ncia da classe Database com as credenciais\n    db = Database(\n        host=os.getenv('DB_HOST'),\n        port=int(os.getenv('DB_PORT')),\n        user=os.getenv('DB_USER'),\n        password=os.getenv('DB_PASSWORD'),\n        database=os.getenv('DB_NAME')\n    )\n\n    # Crie um processador de consultas e processa as consultas\n    processor = QueryProcessor(db)\n    result_df = processor.process_queries('2019-10-01', '2019-12-31')\n\n    # Exibe o resultado no formato desejado\n    print(result_df.to_string(index=False))\n\n    # Fecha a conex\u00e3o\n    db.close()\n</code></pre>"},{"location":"details/#case-3-visualizacao-de-filmes-por-genero-e-ano","title":"Case 3: Visualiza\u00e7\u00e3o de Filmes por G\u00eanero e AnoHerbert Souto","text":"<p>Este exemplo mostra como criar uma visualiza\u00e7\u00e3o de filmes, categorizados por g\u00eanero, ao longo dos anos. Utiliza a biblioteca matplotlib para gerar gr\u00e1ficos de barras empilhadas.</p> <p>Utilizei a biblioteca matplotlib, geralmente utilizo ela para fazer an\u00e1lises e plot de gr\u00e1ficos, junto ao pandas, dito isso, foi uma escolha natural.</p> <pre><code>import matplotlib.pyplot as plt\nimport pandas as pd\nfrom database import Database\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nclass MovieVisualizer:\n    def __init__(self, db):\n        self.db = db\n\n    def fetch_movies_data(self):\n        query = \"SELECT Genre, Votes, Year FROM IMDB_movies\"\n        movies_df = self.db.execute_query(query)\n        return movies_df\n\n    def plot_genre_distribution_by_year(self):\n        movies_df = self.fetch_movies_data()\n\n        # Quebrar os g\u00eaneros em linhas separadas\n        movies_df['Genre'] = movies_df['Genre'].str.split(',')\n        movies_exploded = movies_df.explode('Genre')\n\n        # Contar a quantidade de filmes por g\u00eanero e ano\n        genre_year_counts = movies_exploded.groupby(['Year', 'Genre']).size().unstack(fill_value=0)\n\n        # Criar um gr\u00e1fico de barras empilhadas\n        genre_year_counts.plot(kind='bar', stacked=True, figsize=(12, 6), colormap='tab20')\n\n        # Adicionar t\u00edtulos e r\u00f3tulos\n        plt.title('Distribui\u00e7\u00e3o de Filmes por G\u00eanero ao Longo dos Anos', fontsize=16)\n        plt.xlabel('Ano', fontsize=14)\n        plt.ylabel('N\u00famero de Filmes', fontsize=14)\n        plt.xticks(rotation=45)\n\n        plt.tight_layout()  # Ajusta o layout para evitar sobreposi\u00e7\u00e3o\n        plt.show()\n\nif __name__ == \"__main__\":\n    # Conex\u00e3o ao banco de dados e execu\u00e7\u00e3o do visualizador\n    db = Database(\n        host=os.getenv('DB_HOST'),\n        port=int(os.getenv('DB_PORT')),\n        user=os.getenv('DB_USER'),\n        password=os.getenv('DB_PASSWORD'),\n        database=os.getenv('DB_NAME')\n    )\n\n    visualizer = MovieVisualizer(db)\n    visualizer.plot_genre_distribution_by_year()\n\n    db.close()\n</code></pre> GitHub"},{"location":"sobre/","title":"Sobre o projeto","text":"<p>Este projeto tem como objetivo realizar consultas em um banco de dados MySQL, manipular os dados obtidos e criar visualiza\u00e7\u00f5es usando Python. O projeto utiliza as bibliotecas pandas, mysql-connector-python, matplotlib e python-dotenv para an\u00e1lise de dados e visualiza\u00e7\u00e3o.</p>"},{"location":"usage/","title":"Como usar","text":""},{"location":"usage/#configuracao-do-ambiente","title":"Configura\u00e7\u00e3o do ambiente","text":"<p>Clone o reposit\u00f3rio:</p> <p><pre><code>git clone https://github.com/HerbertSouto/lqbx.git\n</code></pre> Instale as depend\u00eancias usando <code>poetry install</code> ou <code>pip install -r requirements.txt</code>.</p> <pre><code>poetry install\n</code></pre> <ol> <li>Configure as vari\u00e1veis de ambiente para conex\u00e3o ao banco de dados, altere o arquivo \".env-example\" com suas credenciais e renomeie para \".env\":</li> </ol> <pre><code>DB_HOST=seu_host\nDB_PORT=3306\nDB_USER=seu_usuario\nDB_PASSWORD=sua_senha\nDB_NAME=seu_banco\n</code></pre>"},{"location":"usage/#executando-o-projeto","title":"Executando o projeto","text":"<p>Para executar o script:</p> <p><pre><code>poetry run python case_1.py\n</code></pre> <pre><code>poetry run python case_2.py\n</code></pre> <pre><code>poetry run python case_3.py\n</code></pre></p>"}]}